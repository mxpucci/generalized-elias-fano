name: build-linux

# Trigger on every push and allow manual triggering from the GitHub Actions tab
on:
  push:
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      # Check out the repository at the current commit using a Node‑based action
      # outside of any custom container. This avoids the glibc mismatch errors seen
      # when using a CentOS 7 job‑level container with Node 20.
      - uses: actions/checkout@v4

      # Build the project inside an Alpine container using Docker. Alpine uses musl libc,
      # which allows us to produce a fully static binary (-static).
      - name: Build inside Alpine container
        run: |
          docker run --rm -v "$PWD":/workspace -w /workspace alpine:latest sh -c "
            # 1. Install build tools. 
            # REMOVED 'libgomp' from apk add to avoid prioritizing shared libs.
            apk add --no-cache build-base cmake git && \
            
            # 2. Locate the static OpenMP library provided by GCC.
            # This ensures CMake uses the .a file (static) instead of the .so (dynamic).
            STATIC_OMP=\$(gcc -print-file-name=libgomp.a) && \
            
            mkdir -p build && cd build && \
            cmake .. -DCMAKE_POLICY_VERSION_MINIMUM=3.5 \
                     -DCMAKE_BUILD_TYPE=Release \
                     -DCMAKE_CXX_STANDARD=20 \
                     -DGEF_TARGET_ARCH=skylake-avx512 \
                     -DGEF_STATIC_LINK=ON \
                     -DGEF_BUILD_BENCHMARKS=ON \
                     -DGEF_BUILD_TESTS=ON \
                     -DOpenMP_gomp_LIBRARY=\$STATIC_OMP && \
            cmake --build . -- -j\$(nproc)
          "

      # Verify benchmark executables were built successfully
      - name: Verify benchmark executables
        run: |
          ls -lh build/benchmarks/compression_benchmark
          ls -lh build/benchmarks/random_access_benchmark
          ls -lh build/benchmarks/decompression_benchmark
          echo "✓ All benchmark executables built successfully"

      # Ensure CLI binaries from src/ and every tracked test executable were generated.
      - name: Verify CLI and test executables
        run: |
          set -euo pipefail
          echo "CLI binaries:"
          for bin in build/src/ugef \
                     build/src/rle_gef \
                     build/src/bgef \
                     build/src/bgef_no_rle
          do
            if [ -x "$bin" ]; then
              ls -lh "$bin"
            else
              echo "❌ Missing CLI binary: $bin"
              exit 1
            fi
          done

          echo "Test binaries (tracked sources only):"
          had_tests=0
          while IFS= read -r test_src; do
            had_tests=1
            test_name=$(basename "$test_src" .cpp)
            bin="build/tests/${test_name}"
            if [ -x "$bin" ]; then
              ls -lh "$bin"
            else
              echo "❌ Missing test binary: $bin (source: $test_src)"
              exit 1
            fi
          done < <(git ls-files 'tests/*.cpp')

          if [ "$had_tests" -eq 0 ]; then
            echo "❌ No tracked test sources were found (git ls-files returned empty)."
            exit 1
          fi

          echo "✓ CLI and tracked test executables are present"

      # Upload the entire build directory so artifacts include every generated
      # binary (benchmarks, helper tools, etc.).
      - name: Upload benchmarks
        uses: actions/upload-artifact@v4
        with:
          name: gef-linux-benchmarks
          path: |
            build
            !build/**/_deps/**
            !build/**/CMakeFiles/**
            !build/**/*.cmake
            run_benchmarks.sh
            validate_benchmark_json.sh